-- Bloomly Supabase bootstrap schema
-- Covers Charla bookings + blog interactions + newsletter/email updates.

create extension if not exists pgcrypto;

create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

-- =========================
-- Charla (appointments)
-- =========================
create table if not exists public.appointment_settings (
  id integer primary key default 1,
  booking_enabled boolean not null default false,
  price_cents integer not null default 0,
  currency text not null default 'KES',
  available_days text[] not null default '{}',
  time_slots jsonb not null default '{}'::jsonb,
  timezone text not null default 'UTC',
  updated_at timestamptz not null default now()
);

insert into public.appointment_settings (id)
values (1)
on conflict (id) do nothing;

drop trigger if exists trg_appointment_settings_updated_at on public.appointment_settings;
create trigger trg_appointment_settings_updated_at
before update on public.appointment_settings
for each row
execute function public.set_updated_at();

create table if not exists public.appointment_blackouts (
  id bigint generated by default as identity primary key,
  date date not null unique
);

create table if not exists public.appointment_bookings (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  email text not null,
  purpose text not null,
  date date not null,
  time text not null,
  status text not null default 'pending',
  amount_cents integer not null,
  currency text not null default 'KES',
  hold_expires_at timestamptz,
  paid_at timestamptz,
  stripe_session_id text,
  stripe_payment_intent_id text,
  created_at timestamptz not null default now()
);

create index if not exists appointment_bookings_date_time_idx
  on public.appointment_bookings (date, time);
create index if not exists appointment_bookings_status_idx
  on public.appointment_bookings (status);
create index if not exists appointment_bookings_hold_expires_at_idx
  on public.appointment_bookings (hold_expires_at);
create index if not exists appointment_bookings_email_idx
  on public.appointment_bookings (email);

-- =========================
-- Blog interactions
-- =========================
create table if not exists public.likes (
  post_id text primary key,
  count integer not null default 0 check (count >= 0),
  updated_at timestamptz not null default now()
);

drop trigger if exists trg_likes_updated_at on public.likes;
create trigger trg_likes_updated_at
before update on public.likes
for each row
execute function public.set_updated_at();

create table if not exists public.comments (
  id bigint generated by default as identity primary key,
  post_id text not null,
  nick text,
  text text not null,
  timestamp timestamptz not null default now()
);

create index if not exists comments_post_id_timestamp_idx
  on public.comments (post_id, timestamp desc);

-- =========================
-- Newsletter + email updates
-- =========================
create table if not exists public.subscribers (
  id bigint generated by default as identity primary key,
  email text not null unique,
  created_at timestamptz not null default now()
);

create table if not exists public.posts (
  id bigint generated by default as identity primary key,
  title text not null,
  slug text not null unique,
  summary text,
  url text not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

drop trigger if exists trg_posts_updated_at on public.posts;
create trigger trg_posts_updated_at
before update on public.posts
for each row
execute function public.set_updated_at();

create table if not exists public.email_logs (
  id bigint generated by default as identity primary key,
  post_id bigint not null references public.posts(id) on delete cascade,
  email text not null,
  status text not null,
  timestamp timestamptz not null default now()
);

create index if not exists email_logs_post_id_idx on public.email_logs (post_id);
create index if not exists email_logs_email_idx on public.email_logs (email);

-- =========================
-- Row Level Security
-- =========================
alter table public.likes enable row level security;
alter table public.comments enable row level security;
alter table public.subscribers enable row level security;
alter table public.posts enable row level security;
alter table public.email_logs enable row level security;

drop policy if exists likes_read_public on public.likes;
create policy likes_read_public
on public.likes
for select
to anon, authenticated
using (true);

drop policy if exists likes_insert_public on public.likes;
create policy likes_insert_public
on public.likes
for insert
to anon, authenticated
with check (
  char_length(btrim(post_id)) > 0
  and count >= 0
);

drop policy if exists likes_update_public on public.likes;
create policy likes_update_public
on public.likes
for update
to anon, authenticated
using (true)
with check (
  char_length(btrim(post_id)) > 0
  and count >= 0
);

drop policy if exists comments_read_public on public.comments;
create policy comments_read_public
on public.comments
for select
to anon, authenticated
using (true);

drop policy if exists comments_insert_public on public.comments;
create policy comments_insert_public
on public.comments
for insert
to anon, authenticated
with check (
  char_length(btrim(post_id)) > 0
  and char_length(btrim(text)) > 0
  and char_length(text) <= 4000
);

drop policy if exists subscribers_insert_public on public.subscribers;
create policy subscribers_insert_public
on public.subscribers
for insert
to anon, authenticated
with check (
  email ~* '^[^[:space:]@]+@[^[:space:]@]+\\.[^[:space:]@]+$'
);

drop policy if exists posts_read_public on public.posts;
create policy posts_read_public
on public.posts
for select
to anon, authenticated
using (true);

-- Realtime for live like updates in blog post pages.
do $$
begin
  if not exists (
    select 1
    from pg_publication_tables
    where pubname = 'supabase_realtime'
      and schemaname = 'public'
      and tablename = 'likes'
  ) then
    alter publication supabase_realtime add table public.likes;
  end if;
end
$$;
